# Artillery Load Test Configuration
# Feature: 005-use-codebase-analysis
# Test: T029 - Rate Limiting Under Load
#
# Purpose: Validate authentication rate limiting under sustained load
# Simulates 10 requests/second for 30 seconds (300 total requests)
#
# Installation:
#   npm install -g artillery@latest
#   # Or use npx: npx artillery@latest run artillery-auth-load.yml
#
# Usage:
#   artillery run artillery-auth-load.yml
#   artillery run artillery-auth-load.yml --output report.json
#   artillery report report.json  # Generate HTML report
#
# Expected Results:
#   - First ~5 requests per user: 401 Unauthorized
#   - Subsequent requests: 429 Too Many Requests
#   - All 429 responses include Retry-After header
#   - p95 response time: <500ms
#   - p99 response time: <1000ms
#   - No 5xx errors (indicates race conditions or crashes)

config:
  target: "http://localhost:3000"  # Update for production testing
  phases:
    - duration: 30  # 30 seconds
      arrivalRate: 10  # 10 requests per second
      name: "Sustained load - rate limiting validation"

  # Performance thresholds
  ensure:
    maxErrorRate: 0  # No 5xx errors allowed
    p95: 500  # 95th percentile response time <500ms
    p99: 1000  # 99th percentile response time <1000ms

  # Request defaults
  defaults:
    headers:
      Content-Type: "application/json"
      User-Agent: "Artillery-Load-Test/1.0"

  # Variables for test data
  variables:
    testEmail:
      - "loadtest-user1@example.com"
      - "loadtest-user2@example.com"
      - "loadtest-user3@example.com"
      - "loadtest-user4@example.com"
      - "loadtest-user5@example.com"
    invalidPassword:
      - "WrongPassword123!"

  # Plugins for enhanced reporting
  plugins:
    expect: {}  # Response validation
    metrics-by-endpoint: {}  # Per-endpoint metrics

scenarios:
  # Scenario 1: Failed authentication attempts (rate limiting)
  - name: "Failed Authentication - Trigger Rate Limiting"
    weight: 70  # 70% of traffic
    flow:
      - post:
          url: "/api/auth/email-signin"
          json:
            email: "{{ testEmail }}"
            password: "{{ invalidPassword }}"
          capture:
            - json: "$.error"
              as: "errorMessage"
            - header: "retry-after"
              as: "retryAfter"
            - header: "x-ratelimit-remaining"
              as: "rateLimitRemaining"
          expect:
            # Should be either 401 (first 5) or 429 (after lockout)
            - statusCode:
                - 401
                - 429
            - contentType: json
            # If 429, must have Retry-After header
            - ifTrue: "{{ $statusCode == 429 }}"
              headerExists: "retry-after"
          afterResponse: |
            // Log response details for analysis
            console.log(`Status: ${statusCode}, Remaining: ${rateLimitRemaining}, RetryAfter: ${retryAfter}`);

  # Scenario 2: Successful authentication (no rate limiting)
  - name: "Successful Authentication - No Rate Limiting"
    weight: 30  # 30% of traffic
    flow:
      - post:
          url: "/api/auth/email-signin"
          json:
            email: "valid-user@example.com"  # Pre-seeded valid user
            password: "ValidPassword123!"
          expect:
            - statusCode: 200
            - contentType: json
            - hasProperty: "success"

  # Scenario 3: Rate limit status check
  - name: "Rate Limit Status API Check"
    weight: 10  # 10% of traffic (if endpoint exists)
    flow:
      - get:
          url: "/api/auth/rate-limit-status?email={{ testEmail }}"
          expect:
            - statusCode: 200
            - contentType: json
            - hasProperty: "isLocked"
            - hasProperty: "attemptsRemaining"

  # Scenario 4: Concurrent requests (same user)
  - name: "Concurrent Requests - Race Condition Test"
    weight: 20  # 20% of traffic
    flow:
      # Fire 3 rapid requests for same user
      - parallel:
          - post:
              url: "/api/auth/email-signin"
              json:
                email: "concurrent-test@example.com"
                password: "WrongPassword!"
          - post:
              url: "/api/auth/email-signin"
              json:
                email: "concurrent-test@example.com"
                password: "WrongPassword!"
          - post:
              url: "/api/auth/email-signin"
              json:
                email: "concurrent-test@example.com"
                password: "WrongPassword!"

# Custom metrics to track
# These will appear in the Artillery report
metrics:
  - name: "auth_401_count"
    description: "Number of 401 Unauthorized responses"
    type: "counter"

  - name: "auth_429_count"
    description: "Number of 429 Too Many Requests responses"
    type: "counter"

  - name: "retry_after_present"
    description: "429 responses with Retry-After header"
    type: "counter"

  - name: "rate_limit_header_present"
    description: "Responses with X-RateLimit-Remaining header"
    type: "counter"

# Post-test validation
# Artillery will fail the test if these conditions aren't met
after:
  flow:
    - log: "Load test completed. Validating rate limiting behavior..."
    - think: 2  # Wait 2 seconds for cleanup

    # Verify lockout persists
    - post:
        url: "/api/auth/email-signin"
        json:
          email: "loadtest-user1@example.com"
          password: "WrongPassword123!"
        expect:
          - statusCode: 429
          - headerExists: "retry-after"

    - log: "Rate limiting validated successfully"

# Environment-specific overrides
# Usage: artillery run artillery-auth-load.yml --environment production
environments:
  development:
    target: "http://localhost:3000"
    phases:
      - duration: 10  # Shorter test for dev
        arrivalRate: 5

  staging:
    target: "https://staging.paintmixr.app"
    phases:
      - duration: 30
        arrivalRate: 10

  production:
    target: "https://paintmixr.app"
    phases:
      - duration: 60  # Longer sustained test
        arrivalRate: 20  # Higher load
    ensure:
      maxErrorRate: 0
      p95: 300  # Stricter threshold
      p99: 800

# Reporting configuration
reporting:
  # Generate HTML report
  html:
    output: "artillery-report.html"

  # JSON report for CI/CD
  json:
    output: "artillery-report.json"

# Notes for test execution:
#
# PRE-TEST SETUP:
#   1. Ensure test users exist in database:
#      - loadtest-user1@example.com through loadtest-user5@example.com
#      - valid-user@example.com (with password: ValidPassword123!)
#      - concurrent-test@example.com
#
#   2. Clear any existing lockouts:
#      psql -c "UPDATE auth.users SET raw_user_meta_data = jsonb_set(raw_user_meta_data, '{failed_login_attempts}', '0') WHERE email LIKE 'loadtest-%';"
#
#   3. Start application:
#      npm run dev  # Or production server
#
# DURING TEST:
#   - Monitor server logs for errors
#   - Watch database connection pool usage
#   - Check for memory leaks or CPU spikes
#
# POST-TEST CLEANUP:
#   1. Review Artillery HTML report
#   2. Verify no 5xx errors occurred
#   3. Clear lockout metadata:
#      npm run cleanup:test-lockouts
#   4. Archive results for regression comparison
#
# INTERPRETING RESULTS:
#   - 401 responses: Expected for first 5 attempts per user
#   - 429 responses: Expected after 5th attempt (lockout triggered)
#   - Retry-After header: Must be present in ALL 429 responses
#   - Response time: Should stay under thresholds even at peak load
#   - Error rate: Should be 0% (no crashes or race conditions)
